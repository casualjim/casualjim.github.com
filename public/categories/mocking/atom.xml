<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mocking | Ivan Porto Carrero]]></title>
  <link href="http://flanders.co.nz/categories/mocking/atom.xml" rel="self"/>
  <link href="http://flanders.co.nz/"/>
  <updated>2012-04-23T12:05:35+02:00</updated>
  <id>http://flanders.co.nz/</id>
  <author>
    <name><![CDATA[Ivan Porto Carrero]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting started with Caricature and IronRuby]]></title>
    <link href="http://flanders.co.nz/2009/05/21/getting-started-with-caricature-and-ironruby/"/>
    <updated>2009-05-21T14:52:17+02:00</updated>
    <id>http://flanders.co.nz/2009/05/21/getting-started-with-caricature-and-ironruby</id>
    <content type="html"><![CDATA[<p>IronRuby 0.5 was released yesterday. You can download it on <a href="http://ironruby.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=25902#DownloadId=68919">codeplex</a>. This post will explain how you setup your ironruby environment to use it for testing existing CLR based assemblies. We’ll touch installing gems using rake and most importantly writing a test for a CLR based class where we’ll mock out the dependencies.</p>

<p>The first thing you need to do is download <a href="http://ironruby.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=25902#DownloadId=68919">IronRuby</a>. After downloading you can extract it to a location on your hard drive. I extracted mine to C:\ironruby</p>

<p>Now we need to add the path to ir.exe to our PATH variable so we can use it from the command-line. And that is all there is to it to install ironruby on your machine. Now we need to get the necessary gems onto our system. We’ll need bacon and caricature.</p>

<p>Open a console and type the following:</p>

<p>igem list will show you a list of the gems you have installed on your system.</p>

<p>igem install will fetch and install a gem on your system. To install the gems we’re going to need we need to execute the command</p>

<p>igem install bacon caricature</p>

<p>That will result in the following output:</p>

<pre><code>+ C:\tools
» cmd
Microsoft Windows [Version 6.1.7100]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\tools&gt;where ir
C:\ironruby\bin\ir.exe

C:\tools&gt;exit
+ C:\tools
» igem list

*** LOCAL GEMS ***


+ C:\tools
» igem install bacon caricature
Successfully installed bacon-1.1.0
Successfully installed caricature-0.6.0
3 gems installed
Installing ri documentation for bacon-1.1.0...
Installing ri documentation for caricature-0.6.0...
Installing RDoc documentation for bacon-1.1.0...
Installing RDoc documentation for caricature-0.6.0...
</code></pre>

<p>If you would try to execute ibacon at this point that would work. We’ll need to create 2 small files to get ibacon to work. In the bin directory of ironruby I created 2 files one called ibacon and the other one is ibacon.bat</p>

<p>```ruby ibacon</p>

<h1>!C:/ironruby/bin/ir.exe</h1>

<p>#</p>

<h1>This file was generated by RubyGems.</h1>

<p>#</p>

<h1>The application 'bacon' is installed as part of a gem, and</h1>

<h1>this file is here to facilitate running it.</h1>

<p>#</p>

<p>require 'rubygems'</p>

<p>version = ">= 0"</p>

<p>if ARGV.first =~ /<sup><em>(.*)</em>$/</sup> and Gem::Version.correct? $1 then
  version = $1
  ARGV.shift
end</p>

<p>gem 'bacon', version
load 'bacon'
```</p>

<p>``` bat ibacon.bat
@ECHO OFF</p>

<p>@"ir.exe" "%~dpn0" %*
```</p>

<p>At this point you’re ready to start writing specs with bacon and caricature. Let’s look at an example I wrote for the controller factory for ironruby mvc.</p>

<p>We’re going to test the following C# code.</p>

<p>``` csharp Models.cs  <br/>
public interface IWeapon{</p>

<pre><code>int Attack(IWarrior warrior);
int Damage();
</code></pre>

<p>}</p>

<p>public interface IWarrior
{</p>

<pre><code>int Id { get; }    
string Name { get; set; }
bool IsKilledBy(IWeapon weapon);
int Attack(IWarrior target, IWeapon weapon);
int SurviveAttackWith(IWeapon weapon);
</code></pre>

<p>}</p>

<p>public class Sword : IWeapon
{</p>

<pre><code>public int Attack(IWarrior warrior){
    return warrior.SurviveAttackWith(this);
}

public int Damage(){
    return 4;
}
</code></pre>

<p>}
```</p>

<p>I generally create a bacon_helper.rb file where I group my requires and helper functions etc. In the case of this test I have the following in the bacon_helper.rb:</p>

<p>``` ruby bacon_helper.rb</p>

<h1>add some search paths to ironruby</h1>

<h1>this first one adds the path with the assemblies</h1>

<h1>this enables us not to have to specify a path to the assemblies everywhere.</h1>

<p>$: &lt;&lt; File.dirname(<strong>FILE</strong>) + "/bin"</p>

<h1>adds the path to the caricature library.</h1>

<p>$: &lt;&lt; File.dirname(<strong>FILE</strong>) + "/../lib"</p>

<h1>load the caricature library</h1>

<p>require "caricature"
require 'caricature/clr'</p>

<h1>load the bacon library</h1>

<p>require 'bacon'</p>

<h1>Add the .NET framework</h1>

<p>require 'mscorlib'</p>

<h1>load the assembly with the C# code</h1>

<p>load_assembly 'ClrModels'
```</p>

<p>At this point we’re ready to start writing the test. create a file called sword_spec.rb and we’ll add the following content to the file.</p>

<p>``` ruby swordspec.rb  <br/>
require File.dirname(<strong>FILE</strong>) + "/bacon_helper.rb"</p>

<p>describe "ClrModels::Sword" do</p>

<p>  before do</p>

<pre><code>@warrior = Caricature::Isolation.for ClrModels::IWarrior
</code></pre>

<p>  end</p>

<p>  it "should call survive_attack on the mock" do</p>

<pre><code>@warrior.when_receiving(:survive_attack_with).return(5)

sword = ClrModels::Sword.new
sword.attack(@warrior).should.equal 5

@warrior.did_receive?(:survive_attack_with).should.be.successful
</code></pre>

<p>  end</p>

<p>  it "should return different results when expectation is defined with arguments" do</p>

<pre><code>sword1 = ClrModels::Sword.new
sword2 = ClrModels::Sword.new

@warrior.when_receiving(:survive_attack_with).return(5)
@warrior.when_receiving(:survive_attack_with).with(sword2).return(15)

sword1.attack(@warrior).should.equal 5
sword2.attack(@warrior).should.equal 15

@warrior.did_receive?(:survive_attack_with).with(sword2).should.be.successful
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>So now we’ve got 2 tests for our Sword class. The only thing that is left to do is to run the specs. You can do that by executing the ibacon command and passing it the file you want to test.</p>

<pre><code>+ C:\dev\caricature
(master) » ibacon spec/sword_spec.rb
ClrModels::Sword
- should call survive_attack on the mock
- should return different results when expectation is defined with arguments

2 specifications (5 requirements), 0 failures, 0 errors
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Caricature ready for beta]]></title>
    <link href="http://flanders.co.nz/2009/05/19/caricature-ready-for-beta/"/>
    <updated>2009-05-19T15:06:04+02:00</updated>
    <id>http://flanders.co.nz/2009/05/19/caricature-ready-for-beta</id>
    <content type="html"><![CDATA[<p>The last couple of days I’ve been getting <a href="http://github.com/casualjim/caricature">Caricature</a> to a more releasable state. The code got a thorough cleanup and refactor. Caricature now knows how to be a full mocking framework for Ruby classes and CLR classes that only interact with ruby objects. When I apply the 80/20 rule to caricature it’s definitely beta worthy.</p>

<p>I’m not a huge fan of the 80/20 rule unless all the features I want are in the 80 part. In that case for me it’s a 100 rule ;).</p>

<p>As for the latest changes:</p>

<p>Adding <code>require 'caricature'</code> only gives you ruby mocking. If you want to use it to mock CLR classes or interact with the CLR you’ll need to add an extra require statement:<code>require 'caricature/clr'</code>. I’ve done it this way so that I can still add Java and MacRuby support later on.</p>

<p>By default caricature will always give you an instance of an isolation, but there are times that you’ll want to substitute the result of a class method invocation. So the API got expanded with 2 methods, <code>when_class_receives</code> and <code>did_class_receive?</code> These methods enable you to setup substitutions for class method calls.</p>

<p>I’m still waiting for IronRuby 0.5 to be released to give you a blow-by-blow tutorial on how to setup your environment.</p>

<p>Basically you download the ironruby release from <a href="http://ironruby.codeplex.com/Release/ProjectReleases.aspx">Codeplex</a></p>

<p>Then you make sure the path to ir.exe is in your PATH variable</p>

<p>After that you should be able to do igem list and get an empty result back.</p>

<p>now you need to install bacon you can do that by executing</p>

<p>  igem install bacon</p>

<p>next you need the caricature gem</p>

<p>  igem install caricature</p>

<p>You will also need rake to be installed to build the cs files included in the sources.</p>

<p>  igem install rake</p>

<p>ok now you should be good to to</p>

<p>``` ruby <br/>
require 'rubygems'
require 'bacon'
require 'caricature'
require 'caricature/clr'</p>

<p>describe "when isolating Ruby classes with class members" do</p>

<p>  before do</p>

<pre><code>@dagger = Dagger.new
@soldier = Caricature::Isolation.for(SoldierWithClassMembers)
</code></pre>

<p>  end</p>

<p>  it "should work without expectations" do</p>

<pre><code>result = @dagger.attack @soldier
result.should.equal nil
@soldier.did_receive?(:survive_attack_with).with(@dagger).should.be.successful 
</code></pre>

<p>  end</p>

<p>  it "should work for expectations with an argument constraint" do</p>

<pre><code>@soldier.when_receiving(:survive_attack_with).with(@dagger).return(5)
@dagger.attack(@soldier).should.equal 5
@soldier.did_receive?(:survive_attack_with).with(:any).should.be.successful
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>you can get the gem from <a href="http://rubyforge.org/projects/caricature/">rubyforge</a></p>

<p>Or from my github account: <a href="http://github.com/casualjim/caricature">http://github.com/casualjim/caricature</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocking for IronRuby]]></title>
    <link href="http://flanders.co.nz/2009/05/03/mocking-for-ironruby/"/>
    <updated>2009-05-03T14:10:04+02:00</updated>
    <id>http://flanders.co.nz/2009/05/03/mocking-for-ironruby</id>
    <content type="html"><![CDATA[<p>As you may or may not know I’m in the process of building IronRubyMvc. At one point I did write a bunch of tests in for the code I had at that point. However that test code was written in C# with xunit and moq. I wasn’t too happy about that so I deferred writing tests to a later date when I could use a Ruby library to write them.</p>

<p>That time has come, I can use bacon and it’s acceptable performance wise now, not stellar but workable. So when I started to port some of my previously written tests to bacon I ran into a road block. Mocking isn’t as straightforward as my optimistic self was expecting. This lead me to think about what exactly does a mocking framework do?</p>

<p>I’m pretty much a just stuff no fluff kind of guy when it comes to coding. So I tend to choose for solutions that have just the right amount of features and virtually no whistles and bells. I generally blame it on being slightly stupid so I can’t grok intensely complex solutions. Once you cross a treshold there is no way in hell I will ever look at it again.</p>

<p>Anyway the no fluff approach to mocking would be to look at the core responsibilities of those frameworks, which are 2 as far as I can tell.</p>

<ol>
<li>Generate a proxy for an object so you can intercept method calls</li>
<li>Allow for verificatons of those intercepted method calls to do things like how many times was this method called, was it called at all etc.</li>
</ol>


<p>So I’m starting to implement a way to generate proxies today.. This should be a piece of cake with Ruby :) Then I’ll look at implementing some constraints and verifications.</p>

<p>Thinking about how to approach the API for defining the mocks has also been an interesting experience. From the get-go a Record/Replay/Verify model is out. But then it comes to the following part, when do you define the verifications.</p>

<p>Do you do that in the assertion fase, thus stubbing everything beforehand and just allowing the user to define return values when establishing the test context. Or do you define the verification (at least twice, ignore arguments etc) when you establish the test context. My vote goes to the first option.</p>

<p>So a new project is born it’s called caricature and lives on github. Which will try to implement the ideas set forward in this blog post for <a href="http://ironruby.net">IronRuby</a>.</p>

<p><a href="http://github.com/casualjim/caricature">http://github.com/casualjim/caricature</a></p>

<p>Technorati Tags: <a href="http://technorati.com/tags/IronRuby">IronRuby</a>,<a href="http://technorati.com/tags/Mocking">Mocking</a></p>
]]></content>
  </entry>
  
</feed>
