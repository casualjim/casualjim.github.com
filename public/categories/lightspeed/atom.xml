<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lightspeed | Ivan Porto Carrero]]></title>
  <link href="http://flanders.co.nz/categories/lightspeed/atom.xml" rel="self"/>
  <link href="http://flanders.co.nz/"/>
  <link rel="hub" href="http://pubsubhubbub.appspot.com"/>
  <updated>2012-04-22T21:10:37+02:00</updated>
  <id>http://flanders.co.nz/</id>
  <author>
    <name><![CDATA[Ivan Porto Carrero]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ninject (Part 2): Customizing your infrastructure for logging]]></title>
    <link href="http://flanders.co.nz/2008/04/18/ninject-part-2-customizing-your-infrastructure-for-logging/"/>
    <updated>2008-04-18T11:09:18+02:00</updated>
    <id>http://flanders.co.nz/2008/04/18/ninject-part-2-customizing-your-infrastructure-for-logging</id>
    <content type="html"><![CDATA[<p>Yesterday we had a little introduction to <a href="http://ninject.org">Ninject</a>. Today I'd like to examine what's involved in getting some <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a> style logging going for your application. I find that there are only very few places where I'm logging something that steps out of the bounds of being called at the end of the method when things succeed. I'm generally more interested in what happens when things go wrong and that's when I log the exception. In some cases I'll be interested in the actual parameters.</p>

<p>The code I'm going to show you will take care of basic logging needs but if you want more information about what happens inside your method you're either going to need to extend my implementation or log the call from within your method body. We're going to implement logging that when run with the debug level turned on will tell us that a method is going to execute, whether it finished successfully or with an error and if there was an error it will also log the exception.</p>

<p>To get this thing on the road, on the <a href="http://mindscape.co.nz">LightSpeed</a> road that is. We're going to use <a href="http://nlog-project.com">NLog</a> to get flexible routing of log messages. We're first going to create a LightSpeedTarget that is a customized NLog target (route destination) for your log messages.</p>

<p>``` csharp    <br/>
namespace LoggingDemo.UI.Integration
{</p>

<pre><code>/// &lt;summary&gt;
/// This class represents a NLog target that we can reference in the NLog.config file
/// You can use this to use Lightspeed to log to the database just like a file target etc.
/// &lt;/summary&gt;
[Target("LightSpeedTarget")]
public class LightSpeedTarget : TargetWithLayout
{

    public LightSpeedTarget(){
        Layout = "${message}";
    }

    protected override void Write(LogEventInfo logEvent)
    {
        var logMessage = CompiledLayout.GetFormattedMessage(logEvent);

        var appEvent = new ApplicationEvent
        {
            Sequence = logEvent.SequenceID,
            EventTime = logEvent.TimeStamp,
            Level = logEvent.Level.Name,
            LoggerName = logEvent.LoggerName,
            Message = logMessage
        };

        if (logEvent.Exception != null) appEvent.Exception = logEvent.Exception.ToString();
        if (logEvent.StackTrace != null) appEvent.StackTrace = logEvent.StackTrace.ToString();
        if (logEvent.UserStackFrame != null) appEvent.UserStackFrame = logEvent.UserStackFrame.ToString();

        Repository.Add(appEvent);
        Repository.CompleteUnitOfWork();
    }
}
</code></pre>

<p>}
```</p>

<p>The class above overrides the TargetWithLayout class from the NLog project. The attribute tells NLog how to find this target. In the constructor I override the default message layout because it was a bit too verbose to my liking.</p>

<p>We then override the Write method where we map the properties to our ApplicationEvent. And lastly we add the event to the repository and commit it.
Now if we want our application to use this we're going to have to tell it how. Nlog does this by looking for an nlog.config file in your application directory. So let's go ahead and add an nlog.config file to our project. I'll show you the nlog.config file for the application. In my unit test project I'm using the console logger so I can see what's going on :)</p>

<p>The NLog.config file for the application:</p>

<p><img src="http://flanders.co.nz/wp-content/uploads/2008/04/image.png" alt="image" /></p>

<p>My NLog.config file for my test project:</p>

<p><img src="http://flanders.co.nz/wp-content/uploads/2008/04/image1.png" alt="image" /></p>

<p>This enables our application to use the target we just created. Moving on now to the Interceptor which is Ninject specific (You can do the same with other DI frameworks). In Ninject you can tell the kernel to intercept a method on a class and execute some logic before and after invocation of the method. We can tell Ninject to intercept all methods on a class, specific methods or when we say all methods we can still exclude some of them. For our logging example I chose to use all methods on a class. You can do this by decorating the class with an [Intercept] attribute. If you would want a method not to be intercepted you can by decorating that method with an [DoNotIntercept] attribute.</p>

<p>I took the liberty of inheriting of that attribute first.. that makes the rest of my code look a little bit prettier.</p>

<p>The LogMyCallsAttribute:</p>

<p>``` csharp
using Ninject.Core;</p>

<p>namespace LoggingDemo.UI.Interceptors
{</p>

<pre><code>public class LogMyCallsAttribute : InterceptAttribute
{
    public LogMyCallsAttribute() : base(typeof(LoggingInterceptor))
    {
    }
}
</code></pre>

<p>}
```</p>

<p>The LoggingInterceptor:</p>

<p>``` csharp
using System;
using Ninject.Core.Interception;
using Ninject.Core.Logging;</p>

<p>namespace LoggingDemo.UI.Interceptors
{</p>

<pre><code>public class LoggingInterceptor : SimpleFailureInterceptor
{
    private readonly ILogger _logger;
    private bool _hasError;

    public LoggingInterceptor(ILogger logger)
    {
        _logger = logger;
        _hasError = false;
    }
    protected override void BeforeInvoke(IInvocation invocation)
    {
        _logger.Debug("About to invoke {0}", MethodNameFor(invocation));
    }

    protected override void OnError(IInvocation invocation, Exception exception)
    {
        _logger.Error(exception, "There was an error invoking {0}.\r\n", MethodNameFor(invocation));
        _hasError = true;
        base.OnError(invocation, exception);
    }

    protected override void AfterInvoke(IInvocation invocation)
    {
        _logger.Debug("invocation of {0} finished {1}.", MethodNameFor(invocation), (_hasError ? "with an error state" : "successfully"));
    }

    private static string MethodNameFor(IInvocation invocation)
    {
        return invocation.Request.Method.Name;
    }
}
</code></pre>

<p>}
```</p>

<p>This class only overrides a couple of callbacks from its base class the <code>SimpleFailureInterceptor</code>. This is where the actual interception takes place.</p>

<p>``` csharp
using System;
using Ninject.Core;
using Ninject.Core.Interception;</p>

<p>namespace LoggingDemo.UI.Interceptors
{</p>

<pre><code>public abstract class SimpleFailureInterceptor : IInterceptor 
{

    #region IInterceptor Members

    public virtual void Intercept(IInvocation invocation)
    {
        try
        {
            BeforeInvoke(invocation);
            invocation.Proceed();
        }
        catch (Exception ex)
        {
            OnError(invocation, ex);
        }
        finally
        {
            AfterInvoke(invocation);
        }
    }

    #endregion

     protected virtual void BeforeInvoke(IInvocation invocation)
    {
    }

    protected virtual void AfterInvoke(IInvocation invocation)
    {
    }

    protected virtual void OnError(IInvocation invocation, Exception exception)
    {
        throw exception;
    }
}
</code></pre>

<p>}
```</p>

<p>This is al the work that is involved in the actual implementation of our logger. Now I'd like to get some confirmation that things actually do work. Unit testing to the rescue I'd say ;)</p>

<p>The first thing we're going to need is way to verify that stuff actually got intercepted. I did that by subclassing the LoggingInterceptor with a LoggingCounterInterceptor in my unit test project.</p>

<p>``` csharp  <br/>
public class LoggingCounterInterceptor : LoggingInterceptor
{</p>

<pre><code>public int Count { get; private set; }

public int ErrorCount { get; private set; }

public void Reset()
{
    Count = ErrorCount = 0;
}

public LoggingCounterInterceptor(ILogger logger) : base(logger)
{
}

protected override void BeforeInvoke(Ninject.Core.Interception.IInvocation invocation)
{
    Count++;
    base.BeforeInvoke(invocation);
}

protected override void OnError(Ninject.Core.Interception.IInvocation invocation, System.Exception exception)
{
    ErrorCount++;
    base.OnError(invocation, exception);
}
</code></pre>

<p>}</p>

<p>//The attribute for testing
public class LogMyCallsCounterAttribute : InterceptAttribute
{</p>

<pre><code>public LogMyCallsCounterAttribute() : base(typeof(LoggingCounterInterceptor))
{
}
</code></pre>

<p>}</p>

<p>```</p>

<p>In the code above we're just adding 2 counter properties to the interceptor and adding their counts at the appropriate time. Next we're going to need some kind of service class or something on which we can use our interceptor, enter the InterceptedServiceMock.</p>

<p>```csharp  <br/>
public interface IInterceptedServiceMock
{</p>

<pre><code>void MethodWithoutBody();
void MethodThatThrowsAnException();
</code></pre>

<p>}</p>

<p>[LogMyCallsCounter]
public class InterceptedServiceMock : IInterceptedServiceMock
{</p>

<pre><code>public virtual void MethodWithoutBody()
{
    // Nothing to do here
}

public virtual void MethodThatThrowsAnException()
{
    throw new Exception("Because I can.");
}
</code></pre>

<p>}
```</p>

<p>The code above has one method that should execute and one method that throws an exception so we can verify things get picked up accordingly. Now all that's left to do is write the appropriate specs for them and see if they pass :)</p>

<p>``` csharp  <br/>
[Context(Description = "Specifies the behavior for the LogMyCallsInterceptor")]
public class LogMyCallsInterceptorSpec
{</p>

<pre><code>private IKernel _kernel;

[BeforeEach]
public void Before()
{
    var inlineModule = new InlineModule(m =&gt; m.Bind&lt;IInterceptedServiceMock&gt;().To&lt;InterceptedServiceMock&gt;());

    _kernel = new StandardKernel(new LinFuModule(), new NLogModule(), inlineModule);
}

[AfterEach]
public void After()
{
    _kernel.Dispose();
}

[Specification("All this should do is show the calls in the test runner. It should log to the console")]
public void ShouldShowCallsInConsole()
{
    var service = _kernel.Get&lt;IInterceptedServiceMock&gt;();
    IContext context = new StandardContext(_kernel, typeof(IInterceptedServiceMock));

    IRequest request = new StandardRequest(
        context,
        service,
        typeof(InterceptedServiceMock).GetMethod("MethodWithoutBody"),
        new object[0]
    );

    var interceptors = _kernel.GetComponent&lt;IInterceptorRegistry&gt;().GetInterceptors(request);

    var enumerator = interceptors.GetEnumerator();
    enumerator.MoveNext();

    Specify.That(interceptors.Count).Must.Equal(1, "There should be 1 interceptor registered");
    Specify.That(enumerator.Current).Must.Be.InstanceOf(typeof(LoggingCounterInterceptor));

    var interceptor = enumerator.Current as LoggingCounterInterceptor;

    service.MethodWithoutBody();

    Specify.That(interceptor).Must.Not.Be.Null();
    Specify.That(interceptor.Count).Must.Equal(1, "There should be 1 invocation counted.");
}

[Specification("Should show valid counts for a number of invocations")]
public void Should_Show_Correct_Counts_For_Number_Of_Invocations()
{
    var service = _kernel.Get&lt;IInterceptedServiceMock&gt;();
    IContext context = new StandardContext(_kernel, typeof(IInterceptedServiceMock));

    IRequest request = new StandardRequest(
        context,
        service,
        typeof(InterceptedServiceMock).GetMethod("MethodWithoutBody"),
        new object[0]
    );

    var interceptors = _kernel.GetComponent&lt;IInterceptorRegistry&gt;().GetInterceptors(request);

    var enumerator = interceptors.GetEnumerator();
    enumerator.MoveNext();

    Specify.That(interceptors.Count).Must.Equal(1, "There should be 1 interceptor registered");
    Specify.That(enumerator.Current).Must.Be.InstanceOf(typeof(LoggingCounterInterceptor));

    var interceptor = enumerator.Current as LoggingCounterInterceptor;

    service.MethodWithoutBody();
    service.MethodWithoutBody();
    service.MethodWithoutBody();

    Specify.That(interceptor).Must.Not.Be.Null();
    Specify.That(interceptor.Count).Must.Equal(3, "There should be 3 invocations counted.");
    Specify.That(interceptor.ErrorCount).Must.Equal(0, "There should be no errors counted.");
}

[Specification("Should have the correct count of invocations and the correct error count.")]
public void Should_Have_Correct_Invocation_And_Error_Count()
{
    var service = _kernel.Get&lt;IInterceptedServiceMock&gt;();
    var context = new StandardContext(_kernel, typeof(IInterceptedServiceMock));

    var request = new StandardRequest(
        context,
        service,
        typeof(InterceptedServiceMock).GetMethod("MethodWithoutBody"),
        new object[0]
    );

    var errorRequest = new StandardRequest(
        context,
        service,
        typeof (InterceptedServiceMock).GetMethod("MethodThatThrowsAnException"),
        new object[0]
    );

    var interceptors = _kernel.GetComponent&lt;IInterceptorRegistry&gt;().GetInterceptors(request);
    var errorInterceptors = _kernel.GetComponent&lt;IInterceptorRegistry&gt;().GetInterceptors(errorRequest);

    var enumerator = interceptors.GetEnumerator();
    enumerator.MoveNext();
    var errorEnumerator = errorInterceptors.GetEnumerator();
    errorEnumerator.MoveNext();

    Specify.That(interceptors.Count).Must.Equal(1, "There should be 1 interceptor registered");
    Specify.That(enumerator.Current).Must.Be.InstanceOf(typeof(LoggingCounterInterceptor));
    Specify.That(errorInterceptors.Count).Must.Equal(1, "There should be 1 error interceptor registered");
    Specify.That(errorEnumerator.Current).Must.Be.InstanceOf(typeof(LoggingCounterInterceptor));

    var interceptor = enumerator.Current as LoggingCounterInterceptor;
    var errorInterceptor = errorEnumerator.Current as LoggingCounterInterceptor;

    service.MethodWithoutBody();
    service.MethodWithoutBody();
    service.MethodWithoutBody();

    try
    {
        service.MethodThatThrowsAnException();
    }
    catch
    {
    }

    Specify.That(interceptor).Must.Not.Be.Null();
    Specify.That(interceptor.Count).Must.Equal(3, "There should be 3 invocations counted.");
    Specify.That(errorInterceptor.Count).Must.Equal(1, "There should be 1 invocation counted.");
    Specify.That(errorInterceptor.ErrorCount).Must.Equal(1, "There should be 1 error counted.");
}
</code></pre>

<p>}
```
Testing this got a little messy I have to admit that. Now for a concrete example of how that looks in my application:</p>

<p><code>csharp        
[Service(typeof(IBlogService))]
[LogMyCalls]
public class BlogService : DataServiceBase&lt;Blog&gt;, IBlogService
</code></p>

<p>And that's how I implemented logging for my application :) Needless to say it was the testing that took me the longest to write. And from now on I don't have to worry anymore about forgetting that logger call. I always have minimal logging going. AOP is usefull in a lot more cases but this seemed like a good and easy example.</p>

<p>Our next post will deal with initializing the modules in your application and their respective behaviors.</p>

<p><a href="http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f18%2fninject-part-2-customizing-your-infrastructure-for-logging%2f"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f18%2fninject-part-2-customizing-your-infrastructure-for-logging%2f" alt="kick it on DotNetKicks.com" /></a></p>

<p>del.icio.us Tags: <a href="http://del.icio.us/popular/LightSpeed">LightSpeed</a>,<a href="http://del.icio.us/popular/Ninject">Ninject</a>,<a href="http://del.icio.us/popular/NLog">NLog</a>,<a href="http://del.icio.us/popular/Dependency%20Injection">Dependency Injection</a>,<a href="http://del.icio.us/popular/IoC">IoC</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ninject: Getting all the stuff you'll need]]></title>
    <link href="http://flanders.co.nz/2008/04/17/ninject-getting-all-the-stuff-youll-need/"/>
    <updated>2008-04-17T11:13:48+02:00</updated>
    <id>http://flanders.co.nz/2008/04/17/ninject-getting-all-the-stuff-youll-need</id>
    <content type="html"><![CDATA[<p>I have a new project I started and I could reevaluate my toolset :) I decided to take a closer look at <a href="http://ninject.org">Ninject</a>, <a href="http://code.google.com/p/moq/">Moq</a> and <a href="http://https//nspecify.svn.sourceforge.net/svnroot/nspecify">NSpecify</a>. <a href="http://code.google.com/p/moq/">Moq</a> has been talked about enough I think, a really nice way of mocking and I will definitely be using more of it. My original plan was to write one big blog post.. but it is going to be far too long, so I'm breaking it up in smaller bite size pieces.</p>

<p>What I did was download the code, have it rest on my pc for about a week, updated again when I really got round to using it. I read the <a href="http://dojo.ninject.org/wiki/display/NINJECT/Ninject+Manual">wiki</a> which gives a short introduction on what's what in Ninject and everybodies jobs. Decided that the wiki was cool for some more theoretical knowledge but I really needed to see more code.</p>

<p>I opened the project and something rare happened: I was actually very happy with the code I found, not always the case I can tell you ;). Anyway the gold is in the unit tests, it's got great test coverage and it shows lots of the possibilities of Ninject. It's like a great big manual for you to get really advanced with it really quickly. I was slightly disappointed to see that there was no <a href="http://nlog-project.com">NLog</a> support for Ninject, that disappointment quickly turned in to joy when I figured out it only took me 20 minutes to plug NLog in. And it was added to the trunk the same day.</p>

<p>Now I don't want to make this post about which DI framework is better Windsor, Spring, Structuremap or Ninject. I just know that Ninject and I will become good friends over the next couple of months I like it. Ninject outsources its proxy generation to either Castle's DynamicProxy2 or to LinFu DynamicProxy. LinFu seemed like an interesting choice after reading <a href="http://www.codeproject.com/KB/cs/LinFuPart1.aspx">this codeproject article</a>. It's supposedly faster than castle's dynamic proxy. Luckily Ayende is there to put this in <a href="http://www.ayende.com/Blog/archive/2007/10/16/Trusting-the-benchmark.aspx">perspective</a>. And I can confirm that the error messages etc castle's dynamic proxy generates are a lot more useful than LinFu.</p>

<p><img src="http://www.codeproject.com/KB/cs/LinFuPart1/LinFuGraph.png" alt="Screenshot - LinFuGraph.png" /></p>

<p>Anyway I'm using LinFu at the moment as the proxy generator for Ninject. I will walk you through a sample application I built that will deal with the following subjects of Ninject, Lightspeed and NLog. For Ninject we will use the dependency injection and it's interceptor possibilities to implement AOP style logging. For Lightspeed we will create our own logger to plug into the context so that we can log what Lightspeed does too. And we want NLog to log through Lightspeed to our database so we'll be creating a custom target for NLog as well.</p>

<p>But let's start at the beginning doing DI with Ninject :).</p>

<p>The most important thing to remember: <strong>MAKE YOUR METHODS VIRTUAL</strong>. Once again <strong>make your methods virtual </strong>otherwise Ninject has a hard time generating proxies for your classes.</p>

<p>Ninject is different from most other DI Containers in that it doesn't have XML-configuration, its configuration is done through code (wouldn't be hard to add an XML configuration for it tho but what's the point). No XML ?? Suits me fine, everybody that ever worked with me will agree : Ivan no like XML editing. Ninject takes a modular approach by using modules that you pass to a kernel. This is pretty nice that means that an assembly can have a couple of different sets of Modules and all the caller of that assembly needs to do is add the module with the appropriate configuration to their kernel.</p>

<p>Ninject supports DI on constructors, properties, methods and fields: <a href="http://dojo.ninject.org/wiki/display/NINJECT/Injection+Patterns">http://dojo.ninject.org/wiki/display/NINJECT/Injection+Patterns</a>.    <br/>
It basically boils down to decorating the item you want to inject with the attribute <em>[Inject]</em></p>

<p>Ninject allows you to do a lot of configuration through the use of attributes. But I think I'll leave it at that for today and continue this tomorrow.   <br/>
Let's look at a concrete class from what we've seen so far. The class below is the Logger implementation to plug into the LightSpeedContext. We will finish this later on but for now this will be enough to summarize today's post.</p>

<p>``` csharp  <br/>
using Ninject.Core;
using Ninject.Core.Logging;</p>

<p>using ILightSpeedLogger = Mindscape.LightSpeed.Logging.ILogger;
using INinjectLogger = Ninject.Core.Logging.ILogger;</p>

<p>namespace LoggingDemo.UI.Integration
{</p>

<pre><code>///
/// This class intercepts logging messages from the LightSpeed context and
/// sends them to our NLog logger.
///
public class LightSpeedLogger : ILightSpeedLogger
{
    private readonly INinjectLogger logger = NullLogger.Instance;

    public LightSpeedLogger()
    {
    }

    [Inject]
    public LightSpeedLogger(INinjectLogger logger)
    {
        this.logger = logger;
    }

    #region ILogger Members

    public virtual void LogSql(object sql)
    {
        logger.Info(sql.ToString());
    }

    public virtual void LogDebug(object text)
    {
        logger.Debug(text.ToString());
    }

    #endregion
}
</code></pre>

<p>}
```</p>

<p>Let me know what you think :)</p>

<p><a href="http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f17%2fninject-getting-all-the-stuff-youll-need%2f"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f17%2fninject-getting-all-the-stuff-youll-need%2f" alt="kick it on DotNetKicks.com" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updated my lightspeed model generator]]></title>
    <link href="http://flanders.co.nz/2008/04/09/updated-my-lightspeed-model-generator/"/>
    <updated>2008-04-09T18:53:06+02:00</updated>
    <id>http://flanders.co.nz/2008/04/09/updated-my-lightspeed-model-generator</id>
    <content type="html"><![CDATA[<p>This week I could start a project that has a database that goes somewhat beyond a blog. This seemed to me like the best way to improve my model generator that <a href="http://flanders.co.nz/2008/02/09/using-ruby-to-generate-lightspeed-models-part-4-again/">I built earlier</a></p>

<p>And as expected I needed to tweak it a little so that it would work properly, and I added a feature.</p>

<p>Seen as there are 2 files generated for an entity if you add a private field that exists in the database there then the generator will skip it so that you can add more attributes than the ones this script generates for you. If you override a field you also have to put the property in the user file.</p>

<p>I also added support for generating a datacontext. If you want to use the Linq support that Lightspeed is getting then that is a starting point. The same goes for this class with user files and generated file as above, the user file takes precedence.</p>

<p>I hosted this project on <a href="http://code.google.com/p/model-generator-ruby/">google code</a> so you can check it out from there. Or you can download <a href="http://model-generator-ruby.googlecode.com/files/generate_ls_models.zip">todays version</a></p>

<p><a href="http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f09%2fupdated-my-lightspeed-model-generator%2f"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fflanders.co.nz%2f2008%2f04%2f09%2fupdated-my-lightspeed-model-generator%2f" alt="kick it on DotNetKicks.com" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Ruby to Generate LightSpeed Models - Part 4]]></title>
    <link href="http://flanders.co.nz/2008/02/09/using-ruby-to-generate-lightspeed-models-part-4-again/"/>
    <updated>2008-02-09T05:27:42+01:00</updated>
    <id>http://flanders.co.nz/2008/02/09/using-ruby-to-generate-lightspeed-models-part-4-again</id>
    <content type="html"><![CDATA[<p><strong><a href="http://flanders.co.nz/2008/04/09/updated-my-lightspeed-model-generator/">UPDATE</a>: I have an update <a href="http://flanders.co.nz/2008/04/09/updated-my-lightspeed-model-generator/">here</a> with a new version and the location on google code where the project is hosted now.</strong></p>

<p>In the previous 3 parts (<a href="http://flanders.co.nz/blog/archive/2008/02/05/using-ruby-to-generate-lightspeed-models---part-1.aspx">part 1</a>, <a href="http://flanders.co.nz/blog/archive/2008/02/05/using-ruby-to-generate-lightspeed-models.aspx">part 2</a>, <a href="http://flanders.co.nz/blog/archive/2008/02/06/using-ruby-to-generate-lightspeed-models---part-3.aspx">part 3</a>) we talked about getting the meta data out of the database and generating the lightspeed entities in memory.</p>

<p>I won't put the code listings up in this blog post but instead will give you a <a href="http://flanders.co.nz/wp-content/uploads/2008/04/generate_ls_models.zip">link</a> to the complete code :) You can download the express edition of <a href="http://www.mindscape.co.nz/Products/lightspeed/default.aspx">LightSpeed</a> and try it for yourself if you want.</p>

<p>Instead I'll talk about how you can use the ruby script to generate the models from an existing database.</p>

<p>It adds the generated files to the visual studio project file in the same directory or you can specify one.</p>

<p>Currently it only supports Sql Server 2005. You need to create a project first in visual studio so we have a project file to add items to.</p>

<p>To use it you have to tell it which database it has to find by putting a database.yml file in your visual studio project directory.</p>

<p>The content of that database.yml file may look as follows</p>

<h1>on windows you can use the following connection string</h1>

<pre><code>#
# sqlserver:
# database: northwind
# host: localhost
# username: sa
# password: MaybePassword123
#
#
# on OSX and Linux you can connect to sql server through odbc (iODBC or unixODBC in combination with FreeTDS)
#
# sqlserver:
# dsn: NorthwindSql
# username: sa
# password: MaybePassword123
</code></pre>

<p>when you've done that you can execute it like shown in the screenshot below:</p>

<p><a href="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/Terminalscreenshot.jpg"><img src="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/Terminalscreenshot_thumb.jpg" alt="Terminal-screenshot" /></a></p>

<p>I have a database.yml file in the directory and I execute the command ruby &lt;> on linux and OSX you can chmod +x that path and then you don't have to type ruby anymore.</p>

<p>That will generate the models for your database provided that your database conforms to the conventions needed for LightSpeed.</p>

<p>The next step would be to open visuals studio and build the project. The files got added in visual studio every entity are 2 files one with the generated code and one empty one that you can use to implement behavior on the model if you would want to.</p>

<p>The first picture shows how the solution explorer looks and the second one shows the results of the build without having touched one file after generation.</p>

<p>In the download there is a folder db which contains a slightly modified script from the Northwind database that comes with the samples for lightspeed. I used that database because it has every type of relationship and the script did conform to the lightspeed conventions :)</p>

<p><a href="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/LightSpeedGenerateTest.jpg"><img src="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/LightSpeedGenerateTest_thumb.jpg" alt="LightSpeedGenerateTest" /></a></p>

<p><a href="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/LightSpeedGenerateTestBuildResult.jpg"><img src="http://flanders.co.nz/blog/images/UsingRubytoGenerateLightSpeedModelsPart4_1018B/LightSpeedGenerateTestBuildResult_thumb.jpg" alt="LightSpeedGenerateTestBuildResult" /></a></p>

<p><a href="http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fflanders.co.nz%2fblog%2farchive%2f2008%2f02%2f09%2fusing-ruby-to-generate-lightspeed-models---part-4-again.aspx"><img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fflanders.co.nz%2fblog%2farchive%2f2008%2f02%2f09%2fusing-ruby-to-generate-lightspeed-models---part-4-again.aspx" alt="kick it on DotNetKicks.com" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Ruby to Generate LightSpeed Models - Part 3]]></title>
    <link href="http://flanders.co.nz/2008/02/05/using-ruby-to-generate-lightspeed-models-part-3/"/>
    <updated>2008-02-05T20:51:04+01:00</updated>
    <id>http://flanders.co.nz/2008/02/05/using-ruby-to-generate-lightspeed-models-part-3</id>
    <content type="html"><![CDATA[<p>First off I'm writing with windows live writer again, ecto wasn't up to the job. It tried to "clean" my html, granted it was messy but it should leave my text untouched. The whole editing experience wasn't satisfying enough. And Ecto already seemed like the best blog editor for mac, slim pickings indeed. From my tools I expect foremost that they stay out of my way and it didn't. I just talked with <a href="http://codeclimber.net.nz">Simone</a> about looking at making a .NET based client that runs on mono, we'll see where that plan goes because I don't really have time to do that for the moment.</p>

<p>In the previous posts in this series (<a href="http://flanders.co.nz/blog/archive/2008/02/05/using-ruby-to-generate-lightspeed-models---part-1.aspx">part 1</a>, <a href="http://flanders.co.nz/blog/archive/2008/02/05/using-ruby-to-generate-lightspeed-models.aspx">part 2</a>) we discovered how to connect to the database and how to get the meta data about that database out. Maybe I should also explain why I'm doing this series with <a href="http://www.mindscape.co.nz/Products/lightspeed/default.aspx">LightSpeed</a> instead of <a href="http://castleproject.org/activerecord/index.html">ActiveRecord</a> from <a href="http://castleproject.org/">Castle</a> or <a href="http://www.subsonicproject.com/">SubSonic</a> or Linq2Sql for that matter. I will definitely touch on all those orms in the coming week, but I started with LightSpeed because it's the easiest ORM I've ever used.</p>

<p>This post will deal with actually doing something useful with that meta data. Today we're going to generate the represenation of the entities and their properties. Tomorrow we'll deal with actually generating the files from the the in-memory presentation we're generating today.</p>

<p>We're going to need 2 classes in addition to the LightSpeedRepository class. One to represent an entity and one to represent a property. The goal is for tomorrow to render the entities as complete as possible with validation attributes etc.</p>

<p>And without further ado here are the specs we're going to build:</p>

<pre><code>LightSpeedRepository Conversion      
- should convert a given table to light speed metadata       
- should convert a given table without relations to a light speed entity definition       
- should convert a given table with a m:1 relation to a light speed entity definition       
- should convert a given table with a 1:m relation to a light speed entity definition       
- should convert a given table with a m:n relation to a light speed entity definition 



LightSpeedProperty      
- should allow for a property to be set       
- should return a predicate for booleans       
- should return a predicate for booleans       
- should return a sql type       
- should be a lightSpeed property 



LightSpeedEntity      
- should have properties, has many, belongs to and through associations       
- should create a valid property name if one doesn't exists already in the through association properties       
- should create a valid property name if one doesn't exists already in the has many properties       
- should create a valid property name if one doesn't exists already in the belongs to properties       
- should create a valid property name if one doesn't exists already in the properties       
- should create a valid property name if one already exists in the through association properties       
- should create a valid property name if one already exists in the has many properties       
- should create a valid property name if one already exists in the belongs to properties       
- should create a valid property name if one already exists in the properties       
- should create a valid property name if two already exist in the through association properties       
- should create a valid property name if two already exist in the has many properties       
- should create a valid property name if two already exist in the belongs to properties       
- should create a valid property name if two already exist in the properties
</code></pre>

<p>Let's start with looking at the LightSpeedProperty first. The attributes on this class are implemented using some simple <a href="http://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a>. This class will represent a field in a LightSpeed entity and will take care of rendering that properly into the c# file. We actually create the data in the LightSpeedRepository class.</p>

<p>``` ruby  <br/>
class LightSpeedProperty</p>

<p>  attr_accessor :attributes</p>

<p>  def initialize(params = {})</p>

<pre><code>@attributes = params
LightSpeedProperty.create_methods params
</code></pre>

<p>  end</p>

<p>  def <a href="attribute"></a></p>

<pre><code>attributes[attribute]
</code></pre>

<p>  end</p>

<p>  def self.create_methods(params)</p>

<pre><code>params.each do |k, v|
  define_method("#{k}=") do |val|
    @attributes[k]= val
  end

  predicate = %w(primary_key foreign_key unique nullable).any? { |o| o === k.to_s }

  define_method(predicate ? "#{k}?" : "#{k}") do
    @attributes[k]
  end

end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>In the LightSpeed entity class we describe the actual Entity. I monkey patched Array so that I could ask it the question if it has a particular property. To avoid naming conflicts we check for properties that exist already and otherwise give them a generic new name by appending a number.</p>

<p>``` ruby  <br/>
class Array</p>

<p>  def has_property?(name)</p>

<pre><code>exists = false

each do |hm|
  exists = hm[:name] == name
  break if exists
end

exists
</code></pre>

<p>  end
end</p>

<p>class LightSpeedEntity
  attr_accessor :properties, :belongs_to, :has_many, :through_associations, :name, :namespace</p>

<p>  def initialize</p>

<pre><code>@properties = []
@belongs_to = []
@has_many = []
@through_associations =[]
</code></pre>

<p>  end</p>

<p>  def create_property_name_from(from, idx=0)</p>

<pre><code>tname = build_property_name_from from, idx
idx += 1 #when the property exists try with a higher number
return create_property_name_from(from, idx) if has_property?(tname)
tname
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def has_property?(tname)
  properties.has_property? tname or has_many.has_property? tname or belongs_to.has_property? tname or through_associations.has_property? tname
end

def build_property_name_from(from, idx)
  if idx == 0
    from
  else
    "#{from}#{idx}"
  end
end
</code></pre>

<p>end
```</p>

<p>And this brings us to our last class of today the Repository class. We mixin the DB::MetaData module we created yesterday. Define a read_only property entities, make sure we can set a namespace for our generated entities. The first step is to transform the meta data into data that we can use to represent a LightSpeed Entity. The second and last step of today is to generate the entities with the lightspeed meta data. We have to skip the primary key because that is defined by convention in LightSpeed.</p>

<p>``` ruby  <br/>
class LightSpeedRepository</p>

<p>  include DB::MetaData</p>

<p>  attr_reader :entities
  attr_accessor :namespace</p>

<p>  def initialize()</p>

<pre><code>@entities = []
super
</code></pre>

<p>  end</p>

<p>  def to_light_speed_meta_data</p>

<pre><code>tables.collect do |table|
  col_infos = column_info_for table[:name]

  field_infos = col_infos.collect do |col_info|
    {
      :name =&gt; col_info[:name].underscore,
      :sql_type =&gt; col_info[:sql_type],
      :max_length =&gt; col_info[:max_length].to_i,
      :nullable =&gt; !col_info[:is_nullable].to_i.zero?,  
      :precision =&gt; col_info[:precision],
      :foreign_key =&gt; foreign_key?(col_info),
      :primary_key =&gt; primary_key?(col_info),
      :unique =&gt; !col_info[:is_unique].to_i.zero?
    }
  end

  { :table_name =&gt; table[:name], :class_name =&gt; table[:name].singularize.camelize, :fields =&gt; field_infos }
end
</code></pre>

<p>  end</p>

<p>  def generate_entities</p>

<pre><code>meta_data = to_light_speed_meta_data
meta_data.each do |md|
  @entities &lt;&lt; generate_entity(md)
end
@entities
</code></pre>

<p>  end</p>

<p>  def generate_entity(meta_data)</p>

<pre><code>entity = LightSpeedEntity.new
entity.name = meta_data[:class_name]
entity.namespace = namespace

meta_data[:fields].each do |fi|
  prop = LightSpeedProperty.new(fi)

  prop.name = entity.create_property_name_from prop.name.underscore.camelize
  entity.properties &lt;&lt; prop unless prop.primary_key?
  entity.belongs_to &lt;&lt; generate_belongs_to_relation(meta_data, fi, entity) if prop.foreign_key?

end

entity.has_many = generate_has_many_relations meta_data, entity
generate_through_associations meta_data, entity

entity
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def generate_belongs_to_relation(meta_data, field_info, entity)
  { 
    :name =&gt; entity.create_property_name_from(field_info[:name].underscore.humanize.titleize.gsub(/\s/,'')), 
    :class_name =&gt; get_belongs_to_table(meta_data[:table_name], field_info[:name]).underscore.camelize.singularize
  }
end

def generate_has_many_relations(meta_data, entity)
  hms = collect_has_many_relations meta_data[:table_name]
  hms.collect do |hm|
     hm[:name] = entity.create_property_name_from hm[:class_name].pluralize
     hm
  end

end

def generate_through_associations(meta_data, entity)
  tas = collect_through_associations(meta_data[:table_name]) 
  tas.each do |ta|
    ta[:end_tables].each do |et|
      entity.through_associations &lt;&lt; {
        :through =&gt; ta[:through_table].classify.singularize, 
        :class_name =&gt; et.camelize.singularize, 
        :name =&gt; entity.create_property_name_from(et.camelize)
      }
    end
  end
end
</code></pre>

<p>end
```</p>
]]></content>
  </entry>
  
</feed>
